name: Alarm Regression (W&B)

on:
  workflow_run:
    workflows: ["Production"]
    types: [completed]

permissions:
  contents: read
  actions: read
  issues: write
  pull-requests: write

jobs:
  comment-if-regressed:
    runs-on: ubuntu-latest
    if: >
      github.event.workflow_run.event == 'pull_request' &&
      contains(fromJson('["success","neutral"]'), github.event.workflow_run.conclusion)

    steps:
      - uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install deps
        run: |
          python -m pip install --quiet --upgrade requests wandb

      - name: Decide & comment (compare with W&B history)
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_API_URL: ${{ github.api_url }}
          # --- W&B 설정 ---
          WANDB_API_KEY: ${{ secrets.WANDB_API_KEY }} # public이면 없어도 동작
          WANDB_ENTITY: genesis-ai-company
          WANDB_PROJECT: genesis-benchmarks
          # --- 수집/비교 파라미터 ---
          MAX_REVISIONS: "30"                 # 서로 다른 revision 최대 수 (원하면 조절)
          NO_CHANGE_PATIENCE: "500"           # 조기종료 휴리스틱
          RUNTIME_REGRESSION_TOLERANCE_PCT: "10"
          COMPILE_REGRESSION_TOLERANCE_PCT: "10"
        run: |
          python - <<'PY'
          import os, sys, json, io, math, zipfile, requests
          import wandb

          API = os.environ.get("GITHUB_API_URL", "https://api.github.com")
          ev  = json.load(open(os.environ["GITHUB_EVENT_PATH"], "r", encoding="utf-8"))
          wr  = ev["workflow_run"]
          repo= ev["repository"]
          owner, name = repo["full_name"].split("/", 1)
          head_sha = wr.get("head_sha")

          tol_rt = float(os.environ.get("RUNTIME_REGRESSION_TOLERANCE_PCT","10"))
          tol_ct = float(os.environ.get("COMPILE_REGRESSION_TOLERANCE_PCT","10"))
          MAX_REVISIONS = int(os.environ.get("MAX_REVISIONS","30"))
          NO_CHANGE_PATIENCE = int(os.environ.get("NO_CHANGE_PATIENCE","500"))

          sess = requests.Session()
          sess.headers.update({
            "Authorization": f"Bearer {os.environ['GITHUB_TOKEN']}",
            "Accept": "application/vnd.github+json",
          })

          # --- PR 찾기: payload 우선, 없으면 commits/{sha}/pulls fallback ---
          prs = wr.get("pull_requests") or []
          pr = prs[0] if prs else None
          if not pr:
            url = f"{API}/repos/{owner}/{name}/commits/{head_sha}/pulls"
            r = sess.get(url, headers={"Accept":"application/vnd.github.groot-preview+json"})
            if r.ok and r.json():
              pr = r.json()[0]
          if not pr:
            print("No PR found via payload nor commit->pulls. Skip.")
            sys.exit(0)

          pr_num = pr["number"]
          target_repo_api = pr["base"]["repo"]["url"]
          wr_id = wr["id"]

          # ---------- W&B에서 최근 N개의 '서로 다른 revision' 수집 ----------
          ENTITY = os.environ.get("WANDB_ENTITY","")
          PROJECT= os.environ.get("WANDB_PROJECT","")
          api = wandb.Api()

          by_rev = {}    # revision -> {benchmark_id: {runtime_fps, compile_time}}
          rev_order = [] # 최신 -> 과거
          runs_iter = api.runs(f"{ENTITY}/{PROJECT}", order="-created_at")

          selected_revs = None
          no_change_streak = 0

          def as_float(x):
              try: return float(x)
              except: return math.nan

          for run in runs_iter:
              if run.state != "finished":
                  continue
              cfg = run.config or {}
              rev = cfg.get("revision")
              bid = cfg.get("benchmark_id")
              if not rev or not bid:
                  if selected_revs is not None:
                      no_change_streak += 1
                      if no_change_streak >= NO_CHANGE_PATIENCE:
                          break
                  continue

              if selected_revs is not None and rev not in selected_revs:
                  no_change_streak += 1
                  if no_change_streak >= NO_CHANGE_PATIENCE:
                      break
                  continue

              if rev not in by_rev:
                  by_rev[rev] = {}
                  rev_order.append(rev)
                  if len(rev_order) >= MAX_REVISIONS:
                      selected_revs = set(rev_order)

              changed = False
              if bid not in by_rev[rev]:
                  sm = run.summary or {}
                  by_rev[rev][bid] = {
                      "runtime_fps": as_float(sm.get("runtime_fps")),
                      "compile_time": as_float(sm.get("compile_time")),
                  }
                  changed = True

              if selected_revs is not None:
                  if changed:
                      no_change_streak = 0
                  else:
                      no_change_streak += 1
                      if no_change_streak >= NO_CHANGE_PATIENCE:
                          break

          # --- benchmark id 표준화(키 알파벳 정렬) ---
          def normalize_benchmark_id(bid: str) -> str:
              parts = [p.strip() for p in bid.split('-') if p.strip()]
              prefix = [p for p in parts if '=' not in p]
              kv = []
              for p in parts:
                  if '=' in p:
                      k, v = p.split('=', 1)
                      kv.append((k.strip(), v.strip()))
              kv.sort(key=lambda x: x[0])
              out = []
              if prefix: out.extend(prefix)
              out.extend([f"{k}={v}" for k, v in kv])
              return '-'.join(out)

          norm_by_rev = {}
          for rev in rev_order:
              bm = by_rev.get(rev, {})
              nbm = {}
              for old_id, m in bm.items():
                  nid = normalize_benchmark_id(old_id)
                  nbm[nid] = m
              norm_by_rev[rev] = nbm
          by_rev = norm_by_rev

          # --- 이번 PR 커밋의 revision 찾기 (정확 매칭 우선, prefix/short sha fallback) ---
          cur_rev = None
          if head_sha in by_rev:
              cur_rev = head_sha
          else:
              # W&B 쪽이 짧은 SHA거나 반대로 짧게 저장한 경우 대비
              for rev in by_rev.keys():
                  if rev.startswith(head_sha) or head_sha.startswith(rev):
                      cur_rev = rev
                      break

          if not cur_rev:
              print("Current revision not found in W&B runs. Skip comment.")
              sys.exit(0)

          # --- baseline(다른 revision들) 평균과 비교 ---
          others = [r for r in rev_order if r != cur_rev]
          if not others:
              print("No other revisions for baseline. Skip.")
              sys.exit(0)

          import statistics as stats

          cur_bm = by_rev[cur_rev]
          runtime_regs = []  # (id, cur, base_mean, delta_pct)
          compile_regs = []  # (id, cur, base_mean, delta_pct)

          def collect_mean(metric_key, bid):
              vals = []
              for r in others:
                  v = by_rev.get(r, {}).get(bid, {}).get(metric_key)
                  if isinstance(v, (int,float)) and not (isinstance(v, float) and math.isnan(v)):
                      vals.append(float(v))
              if len(vals) == 0: return None
              return stats.mean(vals)

          for bid, m in cur_bm.items():
              cur_rt = m.get("runtime_fps")
              cur_ct = m.get("compile_time")

              base_rt = collect_mean("runtime_fps", bid)
              base_ct = collect_mean("compile_time",  bid)

              if base_rt is not None and isinstance(cur_rt, (int,float)) and not (isinstance(cur_rt,float) and math.isnan(cur_rt)) and base_rt>0:
                  d = (cur_rt - base_rt) / base_rt * 100.0
                  if d < -tol_rt:
                      runtime_regs.append((bid, cur_rt, base_rt, d))

              if base_ct is not None and isinstance(cur_ct, (int,float)) and not (isinstance(cur_ct,float) and math.isnan(cur_ct)) and base_ct>0:
                  d = (cur_ct - base_ct) / base_ct * 100.0
                  if d > tol_ct:
                      compile_regs.append((bid, cur_ct, base_ct, d))

          if not runtime_regs and not compile_regs:
              print("No regression vs W&B baselines. Skip comment.")
              sys.exit(0)

          # --- PR 코멘트 본문 작성 ---
          def trunc(s, n=120): return s if len(s)<=n else s[:n]+"…"
          lines = []
          lines.append(":warning: **Benchmark regression detected (vs W&B history)**")
          lines.append(f"- Revisions considered: **{len(rev_order)}** (excluding current)")
          lines.append(f"- Runtime tolerance: **-{tol_rt:.1f}%**; Compile tolerance: **+{tol_ct:.1f}%**")
          lines.append(f"- Current revision: `{cur_rev}`")
          lines.append("")

          if runtime_regs:
              runtime_regs.sort(key=lambda x: x[3])  # more negative first
              lines += ["**Runtime FPS regressions (vs mean of other revisions)**",
                        "| benchmark_id | current | baseline mean | delta % |",
                        "|---|---:|---:|---:|"]
              for bid, cur, base, d in runtime_regs[:20]:
                  lines.append(f"| `{trunc(bid)}` | {cur:,.0f} | {base:,.0f} | {d:.2f}% |")
              if len(runtime_regs)>20: lines.append("_Only first 20 shown._")
              lines.append("")

          if compile_regs:
              compile_regs.sort(key=lambda x: -x[3])  # more positive first
              lines += ["**Compile-time regressions (vs mean of other revisions)**",
                        "| benchmark_id | current | baseline mean | delta % |",
                        "|---|---:|---:|---:|"]
              for bid, cur, base, d in compile_regs[:20]:
                  lines.append(f"| `{trunc(bid)}` | {cur:,.0f} | {base:,.0f} | {d:.2f}% |")
              if len(compile_regs)>20: lines.append("_Only first 20 shown._")
              lines.append("")

          tag = f"bench-guard-run:{wr_id}"
          lines.append(f"<!-- {tag} -->")
          body = "\n".join(lines)

          # --- 중복 코멘트 방지 & 코멘트 작성 (코멘트 대상은 반드시 base repo) ---
          existing = sess.get(f"{target_repo_api}/issues/{pr_num}/comments").json()
          if any(tag in (c.get("body") or "") for c in existing):
              print("Already commented for this run. Skip.")
              sys.exit(0)
          resp = sess.post(f"{target_repo_api}/issues/{pr_num}/comments", json={"body": body})
          print("Comment status:", resp.status_code, resp.text[:200])
          PY
